var _=function(n){"use strict";const t=Array.isArray,i=(n,t)=>typeof n===t,o=n=>i(n,"undefined"),e=n=>!o(n),c=(n,t)=>e(n[t]),u=n=>o(n)||null===n,r=n=>!u(n)&&i(n,"object"),f=n=>r(n)&&c(n,"length"),s=n=>i(n,"boolean"),a=Object.keys,l=n=>i(n,"string"),b=n=>f(n)||l(n)?0===n.length:!!r(n)&&0===a(n).length,p=Object.entries,h=(n,t)=>n.forEach(t),m=(n,t)=>{h(p(n),(i,o)=>{t(i[1],i[0],o,n)})},j=n=>!u(n)&&(i(n,"object")||i(n,"function")),y=(n,t)=>{if(n===t)return!0;if(j(n)&&j(t)&&a(n).length===a(t).length){let i=!0;return m(n,(n,o)=>{if(!0===i)if(c(t,o)){const e=t[o];i=y(n,e)}else i=!1}),i}return!1},g=n=>!1===n,O=(n,t)=>n instanceof t,D=n=>O(n,Map),d=n=>i(n,"number"),M=n=>j(n)&&n.constructor===Object,E=n=>!r(n),C=(n,t)=>n===t,P=n=>O(n,Set),S=n=>!isNaN(Number(n)),v=n=>i(n,"symbol"),w=n=>!0===n,I=n=>i(n,"function"),N=(n,t)=>n.hasOwnProperty(t),A=(n,t)=>{let i=n;let o=0;for(;e(i)&&o<t.length;){const n=t[o];if(!c(i,n))return null;i=i[n],o++}return i},F=(n,t)=>!u(A(n,t)),R=(n,i)=>h(n,(o,e)=>t(o)?R(o,i):i(o,e,n)),k=(n,t)=>m(n,(i,o,e)=>r(i)?k(i,t):t(i,o,e,n)),T=(n,t,i,o)=>{for(let e=n;e<=t;e+=i)o(e)},q=(n,t)=>{if(t<1)return[];{const i=[];return T(0,n.length-1,t,o=>{i.push(n.slice(o,o+t))}),i}},x=Array.from,K=(n,t)=>n.map(t),L=(n,i)=>K(n,(o,e)=>t(o)?L(o,i):i(o,e,n)),U=n=>L(x(n),n=>t(n)?x(n):n),B=n=>n.filter(n=>!u(n)&&!b(n)),V=n=>{const t=new Map;h(n,n=>{t.set(n,t.has(n)?t.get(n)+1:1)});return t},_=(n,...t)=>{const i=V([].concat(...t));return n.filter(n=>!i.has(n))},z=n=>{const i=[];h(n,n=>{t(n)?i.push(...z(n)):i.push(n)});return i},G=(n,...t)=>{const i=V([].concat(...t));return n.filter(n=>i.has(n))},H=(n,t,i)=>n>=t&&n<=i,J=(n,t)=>H(t,0,n.length-1)?0===t?n.slice(1):n.slice(0,t).concat(n.slice(t+1)):n,Q=(n,t)=>n.includes(t)?J(n,n.indexOf(t)):n,W=(n,t)=>n.filter((n,i)=>i%t==0),X=n=>x(new Set(n)),Y=n=>t(n)?x(n):Object.assign({},n),Z=(n,t)=>{const i=Y(n);m(i,(n,o,e)=>{i[o]=t(n,o,e,i)});return i},$=(n,t)=>Z(n,(n,i,o,e)=>r(n)?$(n,t):t(n,i,o,e)),nn=n=>$(Y(n),n=>r(n)?Y(n):n),tn=(n,t)=>{const i=Y(n);m(t,(t,o)=>{u(n[o])&&(i[o]=t)});return i},on=(n,t)=>{const i=nn(n);m(t,(t,o)=>{const e=n[o];r(t)?i[o]=r(e)?on(e,t):t:i[o]=u(e)?t:e});return i},en=(n,t,i,o=!0,e=!0,c=!0)=>Object.defineProperty(n,t,{value:i,enumerable:o,writable:e,configurable:c}),cn=Object.assign,un=Object.values,rn=n=>new Map(p(n)),fn=(n,t,i)=>n<t?t:n>i?i:n,sn=(n=0,t=1)=>n+Math.random()*(t-n),an=(n=0,t=1)=>Math.floor(sn(n,t)/(t-n)*(t-n+1));return n.isSame=C,n.isEqual=y,n.isInstanceOf=O,n.isTypeOf=i,n.isTrue=w,n.isFalse=g,n.isUndefined=o,n.isDefined=e,n.isNil=u,n.isObject=j,n.isObjectLike=r,n.isObjectPlain=M,n.isArray=t,n.isArrayLike=f,n.isMap=D,n.isSet=P,n.isEmpty=b,n.isPrimitive=E,n.isNumber=d,n.isString=l,n.isStringNumber=S,n.isBoolean=s,n.isSymbol=v,n.isFunction=I,n.hasKey=c,n.hasPath=F,n.hasOwnProperty=N,n.getPath=A,n.forTimes=T,n.forEach=h,n.forEachDeep=R,n.forEachEntry=m,n.forEachEntryDeep=k,n.arrClone=x,n.arrCloneDeep=U,n.arrMap=K,n.arrMapDeep=L,n.arrFlattenDeep=z,n.arrCompact=B,n.arrChunk=q,n.arrStep=W,n.arrRemoveIndex=J,n.arrRemoveItem=Q,n.arrCount=V,n.arrDifference=_,n.arrIntersection=G,n.arrUniq=X,n.objClone=Y,n.objCloneDeep=nn,n.objMap=Z,n.objMapDeep=$,n.objDefaults=tn,n.objDefaultsDeep=on,n.objMerge=cn,n.objDefineProperty=en,n.objKeys=a,n.objValues=un,n.objEntries=p,n.mapFromObject=rn,n.numberInRange=H,n.numberClamp=fn,n.numberRandomFloat=sn,n.numberRandomInt=an,n}({});
