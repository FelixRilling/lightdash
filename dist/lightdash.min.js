var lightdash = function (e) {
    "use strict";
    const r = Object,
        n = Array,
        t = Number,
        a = Map,
        s = Set,
        i = Date,
        o = Math,
        l = (e, r) => {
            if (e === r) return !0;
            if (m(e) && m(r) && R(e).length === R(r).length) {
                let n = !0;
                return M(e, (e, t) => {
                    if (!0 === n)
                        if (j(r, t)) {
                            const a = r[t];
                            n = l(e, a)
                        } else n = !1
                }), n
            }
            return !1
        },
        u = (e, r) => e instanceof r,
        f = (e, r) => typeof e === r,
        b = e => f(e, "undefined"),
        h = e => !b(e),
        p = e => b(e) || null === e,
        c = e => n.isArray(e),
        m = e => u(e, r),
        g = e => !p(e) && f(e, "object"),
        y = e => j(e, "length") ? 0 === e.length : !!g(e) && 0 === R(e).length,
        j = (e, r) => h(e[r]),
        D = (e = 0, r = 1) => e + o.random() * (r - e),
        E = (e, r) => e.forEach(r),
        d = (e, r) => E(e, (n, t) => c(n) ? d(n, r) : r(n, t, e)),
        M = (e, r) => {
            E(v(e), (n, t) => {
                r(n[1], n[0], t, e)
            })
        },
        C = (e, r) => M(e, (n, t, a) => m(n) ? C(n, r) : r(n, t, a, e)),
        N = e => n.from(e),
        O = (e, r) => e.map(r),
        S = (e, r) => O(e, (e, n, t) => c(e) ? S(e, r) : r(e, n, t)),
        A = e => {
            const r = [];
            return E(e, e => {
                c(e) ? r.push(...A(e)) : r.push(e)
            }), r
        },
        I = e => r.assign({}, e),
        k = (e, r) => {
            const n = I(e);
            return M(n, (e, t, a) => {
                n[t] = r(e, t, a, n)
            }), n
        },
        F = (e, r) => k(e, (e, n, t, a) => m(e) ? F(e, r) : r(e, n, t, a)),
        R = e => r.keys(e),
        v = e => r.entries(e);
    return e.isSame = ((e, r) => e === r), e.isEqual = l, e.isInstanceOf = u, e.isTypeOf = f, e.isUndefined = b, e.isDefined = h, e.isNil = p, e.isBoolean = (e => f(e, "boolean")), e.isNumber = (e => f(e, "number")), e.isString = (e => f(e, "string")), e.isStringNumber = (e => !isNaN(t(e))), e.isSymbol = (e => f(e, "symbol")), e.isObject = m, e.isObjectLike = g, e.isArray = c, e.isArrayLike = (e => g(e) && j(e, "length")), e.isMap = (e => u(e, a)), e.isSet = (e => u(e, s)), e.isDate = (e => u(e, i)), e.isEmpty = y, e.hasKey = j, e.hasPath = ((e, r) => {
        let n = e,
            t = 0;
        for (; h(n) && t < r.length;) {
            const e = r[t];
            if (!j(n, e)) return !1;
            n = n[e], t++
        }
        return !0
    }), e.getPath = ((e, r) => {
        let n = e,
            t = 0;
        for (; h(n) && t < r.length;) {
            const e = r[t];
            if (!j(n, e)) return null;
            n = n[e], t++
        }
        return n
    }), e.numberClamp = ((e, r, n) => e < r ? r : e > n ? n : e), e.numberIsInRange = ((e, r, n) => e >= r && e <= n), e.numberRandomFloat = D, e.numberRandomInt = ((e = 0, r = 1) => o.floor(D(e, r) / (r - e) * (r - e + 1))), e.forEach = E, e.forEachDeep = d, e.forEachEntry = M, e.forEachEntryDeep = C, e.arrClone = N, e.arrCloneDeep = (e => S(N(e), e => c(e) ? N(e) : e)), e.arrMap = O, e.arrMapDeep = S, e.arrFlattenDeep = A, e.arrCompact = (e => e.filter(e => !p(e) && !y(e))), e.objClone = I, e.objCloneDeep = (e => F(I(e), e => m(e) ? I(e) : e)), e.objMap = k, e.objMapDeep = F, e.objKeys = R, e.objValues = (e => r.values(e)), e.objEntries = v, e.mapFromObject = (e => new a(v(e))), e
}({});
