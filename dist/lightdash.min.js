var _l=function(r){"use strict";const e=r=>Number.isInteger(r)&&r>=0,t=(r,...e)=>e.some(e=>r instanceof e),n=(r,...e)=>e.some(e=>typeof r===e),a=r=>n(r,"number"),s=r=>null==r,o=r=>!s(r)&&n(r,"object"),i=r=>o(r)&&a(r.length),l=r=>n(r,"string"),c=r=>n(r,"undefined"),u=r=>s(r)?-1:i(r)||l(r)?r.length:c(r.size)?o(r)?Object.keys(r).length:-1:r.size,f=(r,e)=>{for(const[t,n]of Object.entries(r))e(n,t,r)},h=(r,e)=>{if(r===e)return!0;if(!o(r)||!o(e)||r.constructor!==e.constructor||Object.keys(r).length!==Object.keys(e).length)return!1;let t=!0;return f(r,(r,n)=>{!0===t&&(t=!c(e[n])&&h(r,e[n]))}),t},m=r=>n(r,"function"),p=r=>o(r)||m(r),y=r=>n(r,"symbol"),b=(r,e,t)=>r<e?e:r>t?t:r,A=(r,e)=>{if(0===r.length)return e.length;if(0===e.length)return r.length;const t=[];for(let r=0;r<=e.length;r++)t[r]=[r];for(let e=0;e<=r.length;e++)t[0][e]=e;for(let n=1;n<=e.length;n++){const a=t[n],s=t[n-1];for(let t=1;t<=r.length;t++)if(e.charAt(n-1)===r.charAt(t-1))a[t]=s[t-1];else{const r=s[t-1]+1,e=a[t-1]+1,n=s[t]+1;a[t]=Math.min(r,e,n)}}return t[e.length][r.length]},g=r=>r.filter(r=>r),j=(r,e)=>{const t=new Map;return r.forEach((n,a)=>{const o=e(n,a,r);s(o)||t.set(o,t.has(o)?[...t.get(o),n]:[n])}),t},C=r=>{const e=new Map;return r.forEach(r=>e.set(r,e.has(r)?e.get(r)+1:1)),e},E=(...r)=>{if(0===r.length)return[];const e=r[0];return 1===r.length?e:e.concat(...r.slice(1))},d=(r,e)=>r.map((t,n)=>Array.isArray(t)?d(t,e):e(t,n,r)),M=(r,e)=>r.filter((r,t)=>t!==e),S=(r,e)=>{const t=Array.isArray(r)?[]:{};return f(r,(n,a)=>{t[a]=e(n,a,r)}),t},D=(r,e=(()=>null),t=new WeakSet)=>(t.add(r),S(r,(r,n,a)=>t.has(r)?e(r,n,a):o(r)?(t.add(r),D(r,e,t)):r)),k=r=>Object.assign({},r),O=(r,e)=>{const t=Array.isArray(r)?Array.from(r):k(r);return f(e,(e,n)=>{const a=r[n];o(e)?t[n]=o(a)?O(a,e):e:t[n]=c(a)?e:a}),t},I=(r,e)=>S(r,(r,t,n)=>o(r)?I(r,e):e(r,t,n)),T=(r,e)=>r.forEach((t,n)=>Array.isArray(t)?T(t,e):e(t,n,r)),w=(r,e)=>f(r,(t,n)=>o(t)?w(t,e):e(t,n,r)),F=(r=0,e=1,t=!1)=>{const n=e-r;if(0===n)return r;const a=Math.random()*n;return r+(t?a:Math.floor(a/n*(n+1)))};return r.isEqual=h,r.isInstanceOf=t,r.isTypeOf=n,r.isUndefined=c,r.isNil=s,r.isNumber=a,r.isString=l,r.isBoolean=(r=>n(r,"boolean")),r.isSymbol=y,r.isObject=p,r.isObjectLike=o,r.isObjectPlain=(r=>p(r)&&r.constructor===Object),r.isArrayLike=i,r.isArrayBuffer=(r=>t(r,ArrayBuffer)),r.isArrayTyped=(r=>t(r,Int8Array,Int16Array,Int32Array,Uint8Array,Uint16Array,Uint32Array,Float32Array,Float64Array)),r.isPromise=(r=>t(r,Promise)),r.isMap=(r=>t(r,Map)),r.isSet=(r=>t(r,Set)),r.isWeakMap=(r=>t(r,WeakMap)),r.isWeakSet=(r=>t(r,WeakSet)),r.isDate=(r=>t(r,Date)),r.isRegExp=(r=>t(r,RegExp)),r.isFunction=m,r.isError=(r=>t(r,Error)),r.isEmpty=(r=>u(r)<1),r.isIndex=e,r.getPath=((r,e)=>{let t=r,n=0;for(;!c(t)&&n<e.length;){const r=e[n];if(c(t[r]))return null;t=t[r],n++}return t}),r.getSize=u,r.getName=(r=>l(r)?r:p(r)&&!s(r.name)?r.name:y(r)&&!s(r.description)?r.description:null),r.numClamp=b,r.numSafe=(r=>b(r,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),r.strDistance=A,r.strSimilar=((r,e,t=!1)=>{const n=j(e,e=>A(r,e));return t?n:n.get(Math.min(...n.keys()))}),r.strFromKebabCase=(r=>g(r.split("-"))),r.strFromPascalCase=(r=>{const e=[];let t=[];return r.split("").forEach((r,n)=>{n>0&&r!==r.toLowerCase()&&(e.push(t.join("")),t=[]),t.push(r)}),e.push(t.join("")),g(e)}),r.strFromSnakeCase=(r=>g(r.split("_"))),r.strToCamelCase=(r=>r.map((r,e)=>0===e?r.toLowerCase():r.substr(0,1).toUpperCase()+r.substr(1).toLowerCase()).join("")),r.strToKebabCase=(r=>r.map(r=>r.toLowerCase()).join("-")),r.strToPascalCase=(r=>r.map(r=>r.substr(0,1).toUpperCase()+r.substr(1).toLowerCase()).join("")),r.strToSnakeCase=(r=>r.map(r=>r.toLowerCase()).join("_")),r.arrFromDeep=(r=>d(Array.from(r),r=>Array.isArray(r)?Array.from(r):r)),r.arrMapDeep=d,r.arrCompact=g,r.arrChunk=((r,t)=>{if(!e(t)||0===t)return[];const n=[];for(let e=0;e<r.length;e+=t)n.push(r.slice(e,e+t));return n}),r.arrStep=((r,e)=>r.filter((r,t)=>t%e==0)),r.arrRemoveIndex=M,r.arrRemoveItem=((r,e,t=!0)=>t?r.filter(r=>r!==e):M(r,r.indexOf(e))),r.arrCount=C,r.arrCollect=j,r.arrDifference=((r,...e)=>{const t=C(E(...e));return r.filter(r=>!t.has(r))}),r.arrIntersection=((r,...e)=>{const t=C(E(...e));return r.filter(r=>t.has(r))}),r.arrUniq=(r=>Array.from(new Set(r))),r.objFrom=k,r.objFromDeep=(r=>I(k(r),r=>o(r)?k(r):r)),r.objMap=S,r.objMapDeep=I,r.objDefaults=((r,e)=>{const t=Array.isArray(r)?Array.from(r):k(r);return f(e,(e,n)=>{c(r[n])&&(t[n]=e)}),t}),r.objDefaultsDeep=O,r.objDecycle=D,r.mapFromObject=(r=>new Map(Object.entries(r))),r.fnDebounce=((r,e)=>{let t=null;return function(){clearTimeout(t),t=setTimeout(()=>{t=null,r.apply(this,Array.of(arguments))},e)}}),r.fnThrottle=((r,e)=>{let t=null,n=null;return function(){const a=Date.now(),s=()=>{n=a,r.apply(this,Array.of(arguments))};null!=n&&a<n+e?(clearTimeout(t),t=setTimeout(s,e)):s()}}),r.forEachDeep=T,r.forEachEntry=f,r.forEachEntryDeep=w,r.searchBinary=((r,e)=>{let t,n=0,a=r.length-1;for(;n<=a;){const s=r[t=Math.floor(n+(a-n)/2)];if(s===e)return t;s<e?n=t+1:a=t-1}return null}),r.randNumber=F,r.randItem=(r=>r[F(0,r.length-1)]),r.randShuffle=(r=>{const e=Array.from(r);let t=e.length;for(;t--;){const r=F(0,t),n=e[t];e[t]=e[r],e[r]=n}return e}),r}({});
//# sourceMappingURL=lightdash.min.js.map
